(* To jest komentarz *)
// To jest komentarz do końca linii

let x = 10
let y = 1.2

let f x y = x*10 + y

let g x = let y = x*10 in y+1

let multiline x =
    let a = 1
    let b = 2
    x*a + b

let conditional x = if x > 1 then 1 else 0

let list = [1,2,3,4]
let tuple = (1,"a")
let rekord = {A = "s", B = 1}

let [fst, snd] = list
let (a,b) = tuple
let {A -> str} = rekord

let listMatches =
    match list with
    | [3] -> single value
    | [1,2] -> j.w.
    | [...3...] -> list contains 3
    | h:t -> head and list tail
    | [] -> empty

let tupleMatches =
    match tuple with
    | value, value ->
    | var, value ->
    | var, var ->

let recordMatches =
    match rekord with
    | {A = var} ->
    | {A = value} ->
//  | {A::type, B::type, C::type} -> rekord zawiera pola o podanych typach
// The type system shall take care of it


@map :: (a -> b) -> [a] -> [b]
let map f l = 
    match l with
    | x:xs -> f x : map f xs
    | [] -> []
// funkcje są domyślnie rekurencyjne

type Tree<a> = Empty | Node of a * (Tree<a>) * (Tree<a>)
type F<a,b,c> = (a -> b) -> (b -> c) -> a -> c
type IntTree = Tree<Integer>
type Person = {Name :: String, Age :: Integer}
type Teacher extends Person with {Pupils :: [Person]}

let matchUnion tree =
    match tree with
    | Empty -> //..
    | Node (1, tl, tr) -> //..

let Bob = {Name = "Bob", Age = 12}
let Susan = {Bob with Name = "Susan"}
let BobInWork = {Bob with Pupils = [Susan]}

@getName :: Person -> String
let getName p = p.Name

@getFirstPupil :: Teacher -> Person
let getFirstPupil t = head <| t.Pupils

let typeTest () =
    let n1 = getName Bob
    let n2 = getName BobInWork
    //let fp1 = getFirstPupil Bob -- error: getFirstPupil requires additional property 'Pupils' to be present in record `t`
    let fp2 = getFirstPupil BobInWork
    //error: let cannot be the last expression

let main = 
    let i = System.Console.Read() :: Integer
    do System.Console.WriteLine <| toString (i+1)